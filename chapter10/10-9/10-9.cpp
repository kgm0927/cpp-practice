#include <iostream>
#include <vector>
using namespace std;

// 10.4 C++ 표준 템플릿 라이브러리(STL)와 활용
//
// 이 절에서는 C++에서 제공하는 표준 템플릿 라이브러리(STL)의 개요와 활용에 대해
// 간단하게 설명한다.
// 
// * 컨테이너(container)- 탬플릿 클래스
// 
// 
// 데이터를 저장하고 검생하기 위해 담아두는 자료 구조를 구현한 클래스로서,
// 리스트(list), 큐(queue), 스택(stack), 맵(map), 셋(set), 벡터(vector) 등이 있으며,
// 이들을 컨테이너라고 부른다.
// 
// 
// * iterator - 컨테이너 원소에 대한 포인터
// 
// iterator는 반복자라고 부르는 것으로, 컨테이너의 원소들은 하나씩 순회 접근하기 위해 
// 만들어진 컨테이너 원소에 대한 포인터이다. iterator는 원소를 읽을 때 사용하는 iterator,
// 원소를 기록할 때 사용하는 iterator, 둘 다 가능한 iterator등 다양한 iterator가 있다.
// 
// 
// * 알고리즘 - 템플릿 함수
// 
// 컨테이너의 원소에 대한 복사(copy), 검색(find, search), 삭제(remove), 정렬(sort)등의 기능을 구현한 템플릿 함수로서
// 통칭하여 알고리즘이라고 부른다.
// 
// 
// 
// 
// 
// 
// 헤더 파일
// 
// STL은 std 이름 공간에 작성되었기 때문에, STL를 사용하려면 다음 코드가 필요하다.
// 
// using namespace std;
// 
// 
// 
// 그리고 컨테이너 클래스를 사용하고자 하면 해당 템플릿이 선언된 헤더 파일을 include 시켜야 한다.
// 예를 들어 vector 클래스를 사용하고자 하면 다음과 같다.
// 
// #include <vector>
// 
// 
// 
// 알고리즘 함수를 사용하려면 다음과 같이 헤더 파일을 include 해야 한다.
// 
// #include <alogrithm>
// 
// 
// 
// 
// vector 컨테이너 활용
// 
// vector 와 같이 가변 길이 배열을 구현한 제네릭 클래스이다. vector 클래스의 멤버 함수와 연산자 함수를 보여준다.
// vector는 내부의 배열을 가지고 원소를 저장, 삭제, 검색하는 멤버들은 제공한다. vector는 스스로 냅주 크기를 조절하므로,
// 개발자가 vector 크기에 대해 고민할 필요가 없다.
// 
// 
// 
// 
// 
// * vector 객체 생성
// 
// vector 객체를 생성하기 위해서 <> 내에 다루고자 하는 타입을 지정한다. 다음은 int 타입을 저장하는 vector 객체를 생성하는 코드이다.
// 
// vector<int> v;
// 
// v는 오직 int 타입만 다루므로 다음 타입의 값을 삽입하면 오류가 발생한다.
// 
// 
// 
// 
// 
// * vector에 원소 삽입
// 
// 백터에 값을 삽입하기 위해서는 psuh_back() 멤버 함수를 이용한다. psuh_back()은 삽입되는 값을
// 백터의 맨 마지막에 삽입한다. 다음 코드는 1, 2, 3을 순서대로 벡터에 저장되머, 저장된 원소의 개수는
// 3이 된다.
// 
// v.push_back(1);
// v.push_back(2);
// v.push_back(3);
// 
// 
// 
// 
// * vector의 원소 값 읽기 및 변경
// 
// at() 멤버 함수를 이용하면 벡터의 원소에 접근할 수 있다.
// 
// v.at(2)=5; // v의 3번째 원소 값을 5로 변경
// int n=v.at(1); // v의 두 번째 원소 값을 읽어 n에 저장
// 
// 
// 
// 
// 
// vector 클래스에는 [] 연산자가 작성되어 있기 때문에, 벡터를 배열처럼 쉽게 사용할 수 있다.
// [] 연산자를 이용하여 벡터 내의 원소 값을 쓰거나 값을 읽는 사례를 다음과 같다.
// 
// v[2]=5;
// int n=v[1];
// 
// 
// 
// [] 연산자를 이용하여 다음과 같이 벡터의 모든 원소를 출력할 수 있다.
// for(int i=0; i<3; i++)
//		cout<< v[i]<<endl;
// 
// 
// 
// 
// * vector의 원소 개수 알아내기
// 
// 벡터에 존재하는 원소의 개수는 size() 함수를 이용하여 알아낼 수 있다. size()를 이용하면
// 앞의 for 문을 다음과 같이 변경할 수 있다.
// 
// for(int i=0; i<v.size(); i++){
//		cout<< v[i]<< endl;}
// 
// * vector의 원소 삭제
// 
// 벡터에 들어 있는 원소를 개별적으로 삭제하는 멤버 함수로 erase()가 있지만 iterator와 함께
// 사용해야 한다. iterator는 뒤에서 다룬다.
// 
// vector<int>::iterator it;	// it는 정수 벡터의 원소를 가리키는 포인터
// it=v.begin();				// it는 벡터 v의 첫 번째 원소를 가리킨다.
// it=v.erase(it);				// 벡터 v에서 첫 번째 원소를 삭제한다.
// 
// 
// erase(it)는 it가 가리키는 원소를 삭제 후, 벡터의 원소들을 다시 앞으로 한 자리씩
// 이동시킨다. 그리고 삭제된 다음 원소를 가리키는 포인터를 리턴한다. 그러므로 erase(it)
// 후에는 다음과 같이 반드시 it가 리턴 값으로 치환되어야 한다.
// 
// it=v.erase(it);
// 
// 
// 
// 
// 
//  표 10-4: STL vector의 멤버 함수와 연산자 함수
// 
// push_back(element):				벡터의 마지막에 element 추가
// 
// at(int index):					index 위치의 원소에 대한 참조 리턴
// 
// begin() :						벡터의 첫 번째 원소에 대한 참조 리턴
// 
// end():							벡터의 끝(마지막 원소 다음)을 가리키는 참조 리턴
// 
// empty():							벡터가 비어 있으면 true 리턴
// 
// erase(iterator it):				벡터 내 it 위치에 있는 element 삽입
// 
// insert(iterator it, element):	벡터 내 it 위치에 element 삽입
// 
// size():							벡터에 들어 있는 원소의 개수 리턴
// 
// operator[]() :					지정된 원소에 대한 참조 리턴
// 
// operator =():					이 벡터를 다른 벡터에 치환(복사)
// 
// 
//

int main() {
	vector<int> v; // 정수만 삽입 가능한 벡터 생성

	v.push_back(1);// 벡터에 정수 1 삽입
	v.push_back(2);// 벡터에 정수 2 삽입
	v.push_back(3);// 벡터에 정수 3 삽입


	for (int i = 0; i < v.size(); i++)// 벡터에 모든 원소 출력
	{
		cout << v[i] << " ";// v[i]는 벡터의 i 번째 원소 출력
	}
	cout << endl;

	v[0] = 10;			// 벡터의 첫 번째 원소를 10으로 변경
	int m = v[2];		// m에 3 저장
	v.at(2) = 5;		// 벡터의 3 번째 원소를 5로 변경

	for (int i = 0; i < v.size(); i++)// 벡터의 모든 원소 출력
	{
		cout << v[i] << " ";// v[i]는 벡터의 모든 i 번째 원소
	}
	cout << endl;
}