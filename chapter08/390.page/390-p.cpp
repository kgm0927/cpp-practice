#include <iostream>
using namespace std;


// 8.5 상속과 생성자, 소멸자
// 파생 클래스의 생성자와 기본 클래스의 생성자, 파생 클래스의 소멸자와 기본 클래스의 소멸자 사이의 관련성에 대해 설명한다.

//
// 질문 1: 파생 클래스의 객체가 생성이 될 때 파생 클래스의 생성자와 기본 클래스의 생성자가 모두 실행되는가? 아니면 파생 클래스의 생성자만 실행되는가?
// 
// 답: 둘 다 실행된다. 생성자는 객체를 초기화할 목적으로 사용되므로, 파생 클래스의 생성자는 파생 클래스의 멤버를 초기화하거나 필요한 초기 작업을 수행하고,
// 기본 클래스의 생성자는 기본 클래스의 멤버 초기화나 필요한 초기화를 각각 실행한다.
// 
// 질문 2: 파생 클래스의 생성자와 기본 클래스의 생성자 중 어떤 생성자가 먼저 실행되는가?
// 
// 답: 기본 클래스의 생성자가 먼저 실행된다.
// 
// main 함수에서 객체 c를  생성한다.
// 
// C c;
// 
// 이 선언문에 의해 객체 c가 생성될 때, 생성자 c()가 바로 호출된다. 그렇지만 클래스 C는
// 클래스 B를 상속받고 있기 때문에, 생성자 C()는 자신이 실행되기 전에 기본 클래스 B의
// 생성자 B() 호출한다. 생성자 B()는 같은 이유로 실행 전에 생성자 A()를 호출한다.
// 
// 클래스 A는 어떤 클래스도 상속받지 않기 때문에 생성자 A()를 실행하고 리턴한다. 이제 생성자 B()가 
// 실행되고, 다시 리턴하여 생성자 C()가 실행된다.
// 
// 파생 클래스의 생성자가 먼저 호출되지만, 결국 기본 클래스의 생성자가 먼저 실행되고 파생 클래스의
// 생성자가 나중에 실행된다.
// 
// 이는 모두 컴파일러에 의해 이루어진다.
// 
// 
// 
//

class A {
public:
	A() { cout << "생성자 A" << endl; }
	~A() { cout << "소멸자 A" << endl; }

};

class B : public A {
public:
	B() { cout << "생성자 B" << endl; }
	~B()
	{
		cout << "소멸자 B" << endl;
	}
};

class C :public B {
public:

	C() { cout << "생성자 C" << endl; }
	~C()
	{
		cout << "소멸자 C" << endl;
	}
};

int main() {
	C c;

	return 0;
}