#include <iostream>
#include <string>
using namespace std;

int main() {
	string names[5];

	for (int i = 0; i < 5; i++)
	{
		cout << "이름>> ";
		getline(cin, names[i], '\n');

	}

	string latter = names[0];
	for (int i = 1; i < 5; i++)
	{
		if (latter < names[i]) {
			latter = names[i];
		}
	}

	cout << " 사전에서 가장 뒤에 나오는 문자열은 " << latter << endl;
}

//
// 
// 
// <표 4-2> string 클래스의 주요 멤버 함수(표에서 pos는 문자열 내의 문자 위치로서, 0부터 시작함)
// 
// 
//		멤머 함수							|								설명
// ------------------------------------------------------------------------------------------------
//	string& append(const string& str)		| 문자열 뒤에 str 추가
// ------------------------------------------------------------------------------------------------
//	string& append(const string& str,		| str 문자열 내 pos 위치에서 n개의 무자를 현재 문자열
//	int pos, int n)							| 뒤에 덧붙임
// ------------------------------------------------------------------------------------------------
// string& insert(int pos, const string&	| 문자열의 pos 위치에 str 삽입
// str)										|
// ------------------------------------------------------------------------------------------------
// string& replace(int pos, int n,			| 문자열의 pos 위치부터 n개 문자를 str 문자열로 대치
//	const string& str)						|
// ------------------------------------------------------------------------------------------------
// int size()								| 문자열의 길이 리턴, 문자열의 길이는 바이트 수(영어 문자
//											| 개수)
// ------------------------------------------------------------------------------------------------
// int length()								| 문자열 길이 리턴. size()와 동일
//											|
// ------------------------------------------------------------------------------------------------
// int capacity()							| 할당된 메모리 크기 리턴
// ------------------------------------------------------------------------------------------------
// string& erase(int pos, int n)			| pos 위치부터 n개 문자 삭제
// ------------------------------------------------------------------------------------------------
// void clear()								| 문자열 모두 삭제, 크기를 0으로 만듦
//-------------------------------------------------------------------------------------------------
// bool empty()								| 문자열의 크기가 0이면 true, 아니면 false 리턴
// ------------------------------------------------------------------------------------------------
// char& at(int pos)						| pos 위치의 문자 리턴
// ------------------------------------------------------------------------------------------------
// int find(const string& str)				| 문자열의 처음부터 str을 검색하여 발견한 처음 인덱스 리턴,
//											| 없으면 -1 리턴
// ------------------------------------------------------------------------------------------------
// int find(const string& str, int pos)		| 문자열의 pos 위치부터 str을 검색하여 발견한 처음 인덱스
//											| 리턴. 없으면 -1 리턴
// ------------------------------------------------------------------------------------------------
// int rfind(const string& str,int pos)		| 문자열의 pos 위치부터 str을 검색하여 마지막에 발견한
//											| 인덱스 리턴. 없으면 -1리턴
// ------------------------------------------------------------------------------------------------
// int compare(const string& str)			| 문자열과 str을 비교하여 같으면 0을, 사전 순으로 현재 문자열이
//											| 앞에 오면 음수, 뒤에 오면 양수 리턴
// ------------------------------------------------------------------------------------------------
// string substr(int pos,int n)				| pos 위치부터 n개 문자를 새로운 서브스트링으로 생성, 리턴
// ------------------------------------------------------------------------------------------------
// void swap(string& str)					| 현재 객체의 문자열과 str 문자열을 서로 바꿔치기 함
//-------------------------------------------------------------------------------------------------
// char* c_str()							| C-스트링 문자열 리턴
// 
// 
// 
// 	string 클래스의 연산자 
// 
// string s="C++", string s1="C";, string s2="Java"; 일 때
// 
// 
// 
// 연산자		|			설명						| 사용 예			|결과
// ----------------------------------------------------------------------------
// s1=2			|s2를 s1에 치환							| s1=s2				|s1="Java"
// ----------------------------------------------------------------------------
// s []			|s의 [] 인덱스에 있는 문자				|char c=s[1]		|c='+'
// ----------------------------------------------------------------------------
// s1+s2		|s1과 s2를 연결한 새로운 문자열			|s1+s2				|"CJava"
// ----------------------------------------------------------------------------
// s1+=s2		| s1에 s2 문자열 연결					| s1+=s2			|s1="CJava"
// ----------------------------------------------------------------------------
// stream << s	| s를 stream 스트림에 출력				| cout<< s;			| "C++" 출력
// ----------------------------------------------------------------------------
// stream >> s	| stream에서 문자열을 S에 입력			| cin>>s			| 문자열 입력
// ----------------------------------------------------------------------------
// s1==s2		|s1과 s2가 같은 문자열이면 true			|s1==s2				| false
// ----------------------------------------------------------------------------
// s1!=s2		|s1과 s2가 다른 문자열이면 false		|s1!=s2				| true
// ----------------------------------------------------------------------------
// s1<s2		|s1이 사전 순으로 s2보다 앞에 오면 true | s1<s2				|true
// ----------------------------------------------------------------------------
// s1>s2		|s1이 사전 순으로 s2보다 뒤에 오면 true	| s1>s2				|false
// ----------------------------------------------------------------------------
// s1<=s2		|s1이 s2와 같거나 앞에 오면 true		| s1<=s2			|true
// ----------------------------------------------------------------------------
// s1>=s2		|s1이 s2와 같거나 뒤에 오면 true		| s1>=s2			|false
// 
// 
// 
 

// 
//			문자열 다루기
// 
// 
// 
// 
// * 문자열 치환
// 
// 
// 			문자열 치환은 간단히 = 연산자로 이용한다.
// 
// string a="Java", b="C++";
// a=b;	// a="C++"이 된다. a는 b를 복사한 문자열을 가진다.
// 
// 
// 
// 
// 
// 
// 
// 
// * 문자열 비교
// 
// 문자열 비교는 "compare()" 함수를 사용한다. 이 함수는 두 문자열이 같으면 0, str보다 사전 순으로 앞에 오면
// 음수, 뒤에 오면 양수를 리턴한다.
// 
// 
// string name="Kitae";
// string alias="Kito";
// 
// int res=name.compare(alias);							// name과 alias를 비교한다.
// if(res==0)cout<<"두 문자열이 같다.";					// name과 alias가 동일하다
// else if(res<0) cout<<name<<" < "<<alias<<endl;		// name이 앞에 옴
// else cout<<alias<< " < "<<name<<endl;				// name이 뒤에 옴
// 
// 
// 
// 
// 문자열 비교는 다음과 같이 비교 연산자를 사용하면 더 효과적이다.
// 
// if(name==alias) cot<<"두 문자열이 같다";
// if(name <alias) cout << name << "이 "<<alias <<"보다 사전에서 먼저 나온다.";
// 
// 
// 
// 
// 
// 
// * 두 문자열 연결
// 
// 
// 두 개의 문자열을 연결하기 위해 append() 함수를 사용한다. 다음은 "I"문자열 끝에 "love"를 추가하는
// 예이다.
// 
// 
// string a("I");
// a.append(" love ");
// 
// 
// 문자열은 +,+= 연산자를 이용하여 쉽게 작성할 수 있다.
// 
// string a("I love C++");
// string b(".");
// string c;
// c=a+b;	// a,b에는 문자열 변화가 없고, c=""I love C++."로 변경됨
// c+=b;	// b문자열에는 변화가 없고, c="I love C++.."로 변경됨
// 
// 							
// 
// 
// 
// 
// 
// 
// 
//			문자열 삽입
// 
// string 클래스는 문자열에 새로운 문자열이나 문자의 삽입 삭제가 가능하며, 문자열의
// 일부분을 다른 문자로 변경할 수 있다. 다음은 insert() 함수를 이용하여 a의 인덱스 2 위치에
// "really" 문자열을 삽입하는 코드이다.
// 
// string a("I love C++");
// a.insert(2,"really ");	// a= "I really love C++"
// 
// 다음은 replace() 함수를 이용하여 a의 인덱스 2부터 11개의 문자("really love")를
// "study"로 대치한다.
// 
// a.replace(2,11,"study"); // a="I study C++"
// 
// 
// 
// 
// 
//			문자열 길이
// 
// 문자열 길이는 문자열에 포함된 문자 개수를 말하며, length()와 size() 함수는 문자열 길이를 리턴한다.
// 길이와는 달리 string 객체의 내부 메모리 용량을 리턴하는 capacity()도 있다. 용량은 자동으로 조절되므로
// 개발자가 신경 쓸 필요가 없다.
// 
// 
// string a("I study C++");
// int length=a.length(); // "I study C++"의 문자 개수는 11개이다. length=11
// int size = a.size();	// length()와 동일하게 작동. size =11
// int capacity= a.capacity();	//스트링 a의 현재 용량 capacity=31. 변할 수 있다.
// 
// 
// 
// 
// 
//			문자열 삭제
// 
// erase()는 문자열의 일부분을 삭제하고 clear()는 완전히 삭제한다.
// 
//string a("I Love C++");
// a.erase(0,7);	// a의 처음부터 7개의 문자 삭제. a="C++"로 변경
// a.clear();		// a=""
// 
// 
// 
//			서브스트링
// 
// substr() 함수를 사용하면 문자열에서 일부분을 발췌한 문자열(서브스트링)을 얻을 수 있다.
// 
// 
// string b= "I love C++";
// string c=b.substr(2,4);	// b의 인덱스 2에서 4개의 문자 리턴. c="Love"
// string d=b.substre(2);	// b의 인덱스 2에서 끝까지 문자열 리턴. d="love C++"
// 
// 
// 
// 
//		   문자열 검색
// 
// 문자열 내에 특정 문자열이 존재하는지 검샣나느 기능은 많은 응용에서 사용된다.
// find()는 문자열에서 특정 문자나 문자열을 발견하면 첫 번째 인덱스를 리턴한다.
// 발견하지 못하면 -1을 리턴한다.
// 
// string e="I love love C++";
// int index=e.find("love");			// e에서 "love" 검색. 인덱스 2 리턴
// index=e.find("love",index+1);		// e의 인덱스 3부터 "love" 검색. 인덱스 7 리턴
// index= e.find("C#");					// e에서 "C#"을 발견할 수 없음. -1 리턴
// index= e.find('v',7);				// e의 인덱스 7부터 'v'문자 검색. 인덱스 9 리턴
// 
// 
// 
// 
// 
//		문자열의 각 문자 다루기
// 
// 
// at() 함수와 [] 연산자는 둘 다 문자열의 특정 위치에 있는 문자를 리턴한다. at()과 달리
// [] 연산자를 이용하면 특정 문자를 다른 문자로 수정할 수 있다. 
// 
// string f("I love C++");
// char ch1=f.at(7);		// 문자열 f의 인덱스 7에 있는 문자 리턴. ch1='C';
// char ch2=f[7];			// f.at(7)과 동일한 표현 ch2= 'C'
// f[7]='D';				// f는 "I love D++"
// 
// 
// 
// 문자열 f의 마지막 문자는 다음과 같이 얻을 수 있다.
// 
// char ch3=f.at(f.length()-1);		// ch3은 '+'
// 
// 
// 
//
// 
// 
// 문자열의 숫자 변환, stoi()
// 
// C++ 표준부터는 문자열을 숫자로 변환하는 전역 함수 stoi()를 추가하였다. stoi() 함수는 다음과 같이 사용한다.
// string year="2014";
// int n=stoi(year);	// n은 정수 2014
// // int n=atoi(year.c_str()); // 비주얼 C++ 2008 이하
// 
// 
// 
// 
// 문자 다루기
// 
// string은 문자열만 다루지 문자를 다루는 기능은 없다. 문자를 다루는 함수는 <locale>헤더 파일에 존재한다. 다음은 <local>헤더 파일에
// 있는 toupper(), isdigit(), isaplpha() 함수를 사용하는 예이다.
// 
// 
// 
// string a="hello";
// for(int i=0; i<a.length(); i++) a[i]=toupper(a[i]);
// cout<< a; // "Hello" 출력
// if(isdigit(a[0])) cout<<"숫자";
// else if(isalpha(a.at(0))) cout<<"문자"; // a[0]은 문자 'H'  
// 
// 
// 
// 
// 잠깐! 연속적인 스트링 다루기
// 
// append, replace 등 string의 많은 멤버 함수들의 리턴 타입은 string&이다. 이는 다음과 같은 연속적인 스트링 다루기가 가능함을 의미한다.
// string a("I love");
// a.append("Jane").append(" and ").append(" Helen")
//
