//
// 
// 
// 12.4 파일 모드
// 
//				파일 모드란?
// 
// 
// 파일 모드(file mode)란, '파일을 열 때' 앞으로 어떤 파일 입출력을 수행할 것인지 알리는 정보이다.
// 파일 모드는 아래의 표와 같이 ios 클래스에 상수로 선언되어 있다.
// 
// 
// 
// 
// <표 12-1> 파일 상수 모드
// 
// 
// 파일 모드		|			의미
// -----------------------------------------------------------------------------------------
// ios::in					읽기 위해 파일을 연다
// -------------------------------------------------------------------------------------------
// ios::out					쓰기 위해 파일을 연다
// ------------------------------------------------------------------------------------------
// ios::ate					(at end) 쓰기 위해 파일을 연다. 열기 후 파일 포인터를 파일 끝에 둔다. 파일 포인터를
//							옮겨 파일 내의 임의의 위치에 쓸 수 있다.
// ------------------------------------------------------------------------------------------
// ios::app					파일 쓰기 시에만 적용된다. 파일 쓰기 시마다, 자동으로 파일 포인터가 파일 끝으로 옮겨져
//							서 항상 파일의 끝에 쓰기가 이루어진다.
// ------------------------------------------------------------------------------------------
// ios::trunc				파일을 열 때, 파일이 존재하면 파일의 내용을 모두 지워 파일 크기가 0인 상태로 만든다.
//							ios::out 모드를 지정하면 디폴트로 함께 지정된다.
// ------------------------------------------------------------------------------------------
// ios::binary				바이너리 I/O로 파일을 연다. 이 파일 모드가 지정되지 않으면 디폴트가 텍스트 I/O이다.
// ------------------------------------------------------------------------------------------
// 
// 
// 
// '파일 포인터'는 파일 내에 읽거나 쓸 위치를 가리키는 특별한 마크이다.
// 
// 
// 
// 
// 
// 
// 
//				파일 모드 설정
// 
// 
// 
// 파일 모드는 파일을 열 때 지정하며, open() 함수나 ifstream, ofstream, fstream의 '생성자'를 통해 지정한다. open()
// 함수의 경우, 다음과 같이 두 번째 매개변수에 파일 모드를 생성한다.
// 
// 
// void open(const char* filename, ios::openmode mode)
//		mode로 지정되 파일 모드로 finename의 파일을 연다.
// 
// 
// 
// 여기서 mode는 <표 12-1>에 있는 상수이다. 여러 개의 파일 모드를 동시에 정하고자, 하면 다음과 같이 |(bit- OR) 연산자를 이용한다.
// 
// 
// ios::out | ios::app | ios::binary
// 
// 
// ifstream의 디폴트 파일 모드는 ios::in이고, ofstream의 경우 ios::out 이며, fstream의 경우 ios::in|ios::out 이다. 또한
// 텍스트 I/O가 디폴트이다. 
// 
// 
// 
// 
// * student.txt 파일에서 처음부터 읽고자 하는 경우
// 
// 디폴트 파일 모드를 그대로 사용하면 다음과 같다.
// 
// ifstream fin;
// fin.open("student.txt");
// 
// 
// 다음과 같이 명시적으로 파일 모드를 지정할 수 있다.
// 
// ifstream fin;
// fin.open("student.txt", ios::in);
// 
// 
// 
// 
// 
// 
// * student.txt 파일의 끝에 데이터를 저장하는 경우
// 
// 
// ofstream fout;
// fout.open("student.txt", ios::out| ios::app);
// fout<< "tel:0104447777";			// 기존의 student.txt 끝에 "tel:0104447777"을 추가 저장
// 
// 
// 
// 
// 
// 
// 
// * 바이너리 I/O data.bin 파일을 기록하는 경우
// 
// fstream fbinout;
// fbinout.open("data.bin", ios::out | ios::binary);
// char buf[128];
// 
// fbinout.write(buf,128); // buf에 있는 128 바이트를 기록
// 
// 
// 
// 
// * 스트림 객체의 생성자를 이용한 파일 모드 지정
// 
// open() 함수 대신 '스트림 객체의 생성자'를 이용하여 파일 모드를 지정할 수 있다. 앞의 3 가지 사례를
// 생성자를 이용하여 다시 작성하면 다음과 같다.
// 
// ifstream fin("student.txt");
// ofstream fout("student.txt",ios::out | ios:: app);
// fstream fbinout("data.bin",ios::out | ios::binary);
// 
// 
// 
// 
// 
// 
// 12.5 멤버 함수를 이용한 텍스트 I/O
// 
// 텍스트 파일을 읽고 쓰기 위해서는, 파일 모드를 텍스트 I/O로 지정해야 한다. 텍스트 I/O란 앞서 설명한 것처럼 텍스트
// 파일에 들어 있는 문자들을 읽거나, 텍스트 파일에 문자들을 쓰는 입출력 방식이다.
// 
// 
// 
// C++ 입출력 클래스에는 파일에서 한 바이트를 읽고 있는 get()과 put() 함수가 있다.
// 각각 istream과 ostream 클래스의 멤버로서, 텍스트 파일이나 바이너리 파일을 막론하고
// 입출력이 가능하다
// 
// 
// 
// 
//			텍스트 I/O 모드로 열기
// 
// 
// ios::binary를 지정하지 않으면, 텍스트 I/O로 입출력이 이루어진다.
// 
// 
// const char* file= ""; //텍스트 파일
// ifstream fin;		// 파일 입력 스트림 객체 생성
// fin.open(file);		// 텍스트 I/O로 파일 열기
// 
// ofstream fout(file); // 파일 출력 스트림을 생성하고, 텍스트 I/O로 파일 열기
// 
// 
// 
// 
//			get()과 put()을 이용한 텍스트 I/O
// 
// 텍스트 I/O 모드인 경우, get()은 파일에서 문자 한 개를 읽고, put()은 문자 한 개를 파일에 기록한다.
// 
// 
// int get()
//		파일에서 문자 하나(한 바이트) 읽어 리턴, 파일의 끝에서 읽으면 EOF(-1)리턴
// 
// ostream & put(char ch)
//		파일에 문자 ch 기록
// 
// 
// 예제 12-3은 텍스트 파일 c:\windows\system.ini를 텍스트 I/O 모드로 열고, get()을 이용해서 파일을
// 읽어 화면에 출력하는 사례를 읽어준다.
// 
// 
//


#include <iostream>
#include <fstream>
using namespace std;


int main() {
	const char* file = "c:\\windows\\system.ini";	// 읽을 파일명
	ifstream fin(file);
	if (!fin) {
		cout << file << "열기 오류" << endl;
		return 0;
	}
	int count = 0;
	int c;
	while ((c = fin.get()) != EOF) {	//EOF를 만날 때까지 읽음
		cout << (char)c;				//읽은 문자를 화면에 출력
		count++;						// 읽은 문자 개수 카운트
	}

	cout << "읽은 바이트 수는" << count << endl;
	fin.close();

}

// 알아 두어야 할 점
/*
 텍스트 I/O 모드로 읽을 때, get()은 라인의 끝에 있는 '\r\n'의 두 바이트를 
 '\n'의 한 바이트로 리턴한다. 그러므로 c:\\windows\\system.ini는 총 13 라인의
 219바이트이지만, 실제 읽은 바이트 수는 '\r' 개수 만큼 모자란 206개 카운트 된다.*/