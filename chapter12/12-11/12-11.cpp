//
// 바이러니 I/O와 텍스트 I/O의 확실한 차이점
// 
// 
// 바이너리 I/O와 텍스트 I/O는 항상 알 듯 말 듯 하다. get()과 read(), put()과 write()가 
// 바이너리 I/O와 텍스트 I/O에 대해 서로 다르게 작동할까?
// 
// 
// * 파일의 끝을 인식하는 방법에는 차이가 없다.
// 
// 바이너리 I/O와 텍스트 I/O는 파일의 끝을 인식하는데 는 차이가 없다. get() 텍스트
// I/O든 바이너리 I/O든 파일의 끝을 만나면 모두 EOF(-1)을 리턴한다.
// 파일의 끝은 '모드에 상관없이 EOF와 비교'하면 된다.
// 
// 
// 
// 
// * 텍스트 I/O와 바이너리 I/O는 '\n'를 읽고 쓸 때 서로 다르게 작동한다.
// 
//	1. 텍스트 I/O에서 '\n' 입출력
// 
// 텍스트 I/O로 '\n'을 파일에 출력하면 파일에는 '\r\n'의 두 문자가 기록된다.
// 반대로 파일에서 '\r', '\n'의 두 문자를 읽고 '\n' 하나만 리턴한다. 이것은
// 텍스트파일이건 바이너리 파일이건 동일하다.
// 
// 
// fout<<'\n';	// 파일에 '\r','\n'의 두 문자가 기록된다.
// fout.put('\n');// 파일에 '\r','\n'의 두 문자가 기록된다.
// 
// 
// 
// 텍스트 I/O로 get()이 읽는 경우는 다음과 같다.
// 
// int ch=fin.get(); // 파일에서 '\r', '\n'를 읽고 ch에 '\n' 하나만 리턴한다.
// 
// 
// write()의 경우도 동일하다. 다음 코드를 실행하면 buf[] 배열에 있는 문자 '\n'이 파일에
// 기록될 때 '\r', '\n'의 두 문자로 변환되어 저장된다.
// 
// char buf[]={'a','b','\n'};
// fout.write(buf,3);
// 
// 이 코드의 실행 결과는 '\r','\n'의 두 문자로 기록된다.
// 
// 
// 
// 
// 2. 바이너리 I/O에서 '\n' 입출력
// 
// 바이너리 I/O인 경우 '\n'과 '\r'을 특별하게 다루지 않고 그대로 읽고 쓴다. 다음 코드는
// '\n'만 저장한다. 이것은 텍스트 파일이든 바이너리 파일이든 동일하다.
// 
// 
// ofstream fout("c:\\temp\\student3.txt", ios::out| ios::binary);
// char buf[]={'a','b','\n'};
// fout.write(buf,3);
// 
// 위의 실행 결과 '\n'만 기록된다.
// 
// 
// 
// 
// 
// 
// 12.7 스트림 상태 검사
// 
// 
// 파일 입출력 스트림은 '스트림 상태(stream state)'를 저장하는 멤버 변수를 두고, 입출력이 진행되는 동안
// '오류(error) 정보'를 유지한다(책 623.page 참조). 아래의 표는 각 오류 비트의 상수를 보여준다.
// 
// 
// 
// 
// 
// <표12-2> 스트림의 상태를 나타내는 각 비트
// 
// 비트			|						설명
// ---------------------------------------------------------------------------
// eofbit					파일의 끝을 만났을 때 1로 세팅
// ---------------------------------------------------------------------------
// failbit			정수를 입력받고자 하였으나 문자열이 입력되는 등 포맷 오류냐
//					, 쓰기 금지된 곳에 쓰기를 하는 등 전반적인 I/O 실패시에 1로
//					세팅
// ---------------------------------------------------------------------------
// badbit			스트림이나 데이터가 손상되는 수준의 진단되지 않은 문제가 발생한 경우나
//					유효하지 않은 입출력 명령이 주어졌을 때 1로 세팅
// 
// 
// 
// 
// 
// 
// 
// 
// 응용 프로그램에서는 아래의 표를 보면 된다.
// 
// 
// <표12-3>	스트림의 상태를 검사하는 멤버 함수
// 
// 멤버 함수		|			설명
// --------------------------------------------------------------------
// eof()				파일의 끝을 만났을 때(eofbit=1)
// --------------------------------------------------------------------
// fail()				failbit()나 badbit가 1로 세팅되어 있을 때 True 리턴
// --------------------------------------------------------------------
// bad()				badbit이 1로 세팅되었을 때 true 리턴
// --------------------------------------------------------------------
// good()				스트림이 정상적(모든 비트가 0)일 때 true 리턴
// --------------------------------------------------------------------
// clear()				스트림 상태 변수를 0으로 지움
// 
// 
// 
// 밑의 예제는 파일 입출력 시 오류가 발생하는 경우 스트림의 상태를 검사하는 몇 가지 사례를 보여준다.
// 
// 
// 
//
#include <iostream>
#include <fstream>
using namespace std;

void showStreamState(ios& stream) {
	cout << "eof() " << stream.eof() << endl;
	cout << "fail() " << stream.eof() << endl;

	cout << "bad() " << stream.bad() << endl;
	cout << "good() " << stream.good() << endl;
}

int main() {


	const char* noExistFile = "c:\\temp\\noexist.txt";	// 존재하지 않은 파일명
	const char* existFile = "c:\\temp\\student.txt";	// 존재하는 파일명

	ifstream fin(noExistFile);	// 존재하지 않는 파일 열기
	if (!fin) {					// 열기 실패 검사
		cout << noExistFile << " 열기 오류" << endl;
		showStreamState(fin);// 스트림 상태 출력


		cout << existFile << " 파일 열기" << endl;
		fin.open(existFile);
		showStreamState(fin);// 스트림 상태 출력

	}


	// 스트림을 끝까지 읽고 화면에 출력

	int c;
	while ((c = fin.get() )!= EOF)
		cout.put((char)c);


	cout << endl;
	showStreamState(fin); // 스트림 상태 출력

	fin.close();


	


}