//
// 
// 
// 
// 
// 12.1 텍스트 파일과 바이너리 파일
// 
// 
// 
// 파일(file): 저장 매체에 저장되는 정보
// 기록되는 데이터의 종류에 따라 따라 '텍스트 파일(text file)', '바이너리 파일(binary file)'로 나뉜다.
// 
// 
// 
// 
//	
// 
// 
// 
//			텍스트 파일
// 
// 텍스트 파일: 사람들이 사용하는 글자(letter) 혹은 문자(character)만으로 구성되는 문서 파일
// 
// 텍스트 파일 사례
//		txt 파일, HTML 파일, XML 파일, C++ 소스 파일, C 소스 파일, 자바 소스 파일
// 
// 
// 
// 
// 
// 
//			바이너리 파일
// 
// 사진 이미지, 오디오, 그래픽 이미지, 컴파일된 코드 등은 문자로 표현되지 않는 파이너리 정보들이다.
// 바이너리 파일은 문자뿐 아니라, 이런 바이너리 정보를 저장한다. 텍스트 파일의 각 바이트들은 모두 문자들로
// 해석되지만, 바이너리 파일의 각 바이트는 파일을 만든 응용 프로그램만이 해석할 수 있다.
// 
// 
// * 바이너리 파일의 사례
// 
//		jpeg, bmp 등의 이미지 파일
//		mp3 등의 오디오 파일
//		hwp, doc, ppt 등의 확장자를 가진 멀티미디어 문서 파일
//		obj, exe 등의 확장자를 가진 컴파일된 코드나 실행 파일
// 
// 
// * 바이너리 파일 내부 보기
// 
// 바이너리 파일의 내부를 볼 경우, 파일에는 문자로 해석할 수 없는 바이너리 값들이 존재한다. 만약 이런
// 값들이 존재한다면 이는 바이너리 파일이다.	
// 
// 
// 
// 
// 
// 
// 12.2 파일 입출력 개요
// 
//			C++ 파일 입출력 라이브러리
// 
//		C++ 표준 파일 입출력 라이브러리의 핵심 클래스를 보여준다.
// 
//					ifstream: 파일 읽기 
//					ofstream: 파일 쓰기
//					fstream: 하나의 파일에 읽기와 쓰기를 동시에 할 때 사용한다.	
// 
// 
// 이들은 basic_ifstream, basic_ofstream, basic_fstream등의 탬플릿 클래스에 char 타입으로 구체화하고
// typedef 으로 선언된 클래스이다.
// 
// 
// 
// 
// 
// 
//			파일 입출력 스트림은 파일을 프로그램과 연결한다.
// 
// 
// 
//	ifstream이나 ofstream은 '파일을 프로그램과 연결'하는 스트림으로서, 프로그램은 ifstream 객체를
//	통해 파일에서 읽고 ofstream 객체를 통해 파일 쓰기를 진행한다.
// 
// 
// 11 장에서 다룬 ios,istream, ostream, iostream 클래스의 멤버 함수들은 파일 입출력에서도 사용된다. 
// 
// 
// istream의 get()은 스트림이 키보드에 연결되어 있다면 키보드에서 문자 하나를 읽고, 스트림이 파일에 연결되어 있다면
// 파일에서 문자 하나를 읽는다. 그러므로 ifstream 스트림 객체와 ofstream 스트림 객체가 파일을 연결하면, get(), getline(),
// put(), read(), write() 등의 멤버 함수들은 자연스럽게 스트림에 연결된 파일에서 읽고 쓴다.
// 
// 
// 
// 
//				헤더 파일과 namespace 
// 
//	ifstream, ofstream, fstream을 이용하기 위해서는 <fstream> 헤더 파일과 std 이름 공간이
// 필요하므로 다음 코드가 필요하다.
// 
//			#include <fstream>
//			using namespace std;
// 
// 
// 
// 
//				파일 입출력 모드: 텍스트 I/O 와 바이너리 I/O
// 
// 
// * 텍스트 I/O
// 문자들만 기록하고, 파일에 있는 바이트를 문자로만 해석하는 입출력 방식으르서, 텍스트 파일을 읽고 쓸 때만
// 사용한다.
// 
// * 바이너리 I/O
// 바이트 단위로 바이너리 데이터를 입출력하는 방식이다. 모든 파일을 단순히 바이트의 스트림으로 다루기 때문에,
// 텍스트 파일이나 바이너리 파일에 상관없이 읽고 쓰기가 가능하다.
// 
// 
// 파일의 입출력 모드는 ifstream, ofstream, fstream의 생성자에 지정하거나 파일 열기(open) 시에 지정하여야 하며
// 방법은 12.4 절에 나온다.
// 
// 
// 
// 
// 
// 
// 
// 12.3 <<,>> 연산자를 이용한 간단한 텍스트 파일 입출력
// 
//  
// 
// 간단히 텍스트 파일을 읽고 쓰려면 <<,>> 연산자를 사용하면 편리하다. <<,>> 연산자는 오로지 텍스트 파일에 대해서만 작동한다.
// 
// 
// ofstream fout; // 파일 입출력 객체 fout 생성
// 
// 
// 
//	
// 
// 
//				파일 열기
// 
// 텍스트 데이터를 파일에 쓰기 전에, 파일명을 매개 변수로 하고 fout 객체의 open() 멤버 함수를 호출하여 파일을 열어 스트림에 연결해야 한다.
// 
// 
// fout.open("song.txt"); //song.txt 파일 열기
// 
// 
// 파일 열기는 '출력 스트림에 파일을 연결하는 과정'이다. 이 과정에서 song.txt가 읽기 전용(read-only) 파일로 이미 존재하거나, 디스크 용량이 모자라는 등
// 파일 만들기가 불가능한 경우 파일 열기는 실패한다. 앞의 open() 함수는 song.txt 파일이 존재하지 않는다면 빈 song.txt 파일을 새로 만들고, 이미 존재했다면
// 기존의 파일의 내용을 모두 지우고 파일의 맨 앞에서부터 쓸 준비를 한다. 
// 
// 
// 
// open() 함수를 사용하지 않고 다음과 같이 파일 출력 스트림을 생성할 때 파일 열기를 함께 할 수 있다.
// 
// 
// ofstream fout("song.txt");// 파일 출력 스트림 생성과 동시에 파일 열기
// 
// 
//				
// 
// 
//				파일 열기 성공 검사
// 
// 
// 
// 파일 열기가 실패할 시 파일 쓰기를 더 이상 진행할 수 없기 때문에, 열기 후에는 반드시 열기의 성공 여부를 검사한다.
// 다음과 같은 방식으로 작동한다.
// 
// if(!fout){		// fout 스트림의 파일 열기가 실패한 경우
//			... // 파일 열기 실패를 처리하는 코드	
// }
// 
// 
// 
// !fout은 fout 스트림의 operator!() 연산자 함수를 실행한다. operator!() 함수는 ios 클래스의 멤버이므로 상속받은 모든 입출력 클래스에서 사용가능하다.
// operator!() 함수는 파일 열기가 실패한 경우 true를, 성공한 경우 false를 리턴한다.
// 
// 
// if(!fout.is_open()){	// fout 스트림의 파일 열기가 실패한 경우
// 
//	...		// 파일 열기 실패를 처리하는 코드
// }
// 
// 
// 
// is_open()은 파일 열기가 성공한 경우 true, 실패한 경우 false를 리턴한다. 여기서 !는 중복된 연산자가 아니다.
// 
// 
// 
// 
// 
// 
// 
// 
//				파일 닫기
// 
// 파일 쓰기를 마치면 다음과 같이 close() 함수를 호출하여 파일을 닫는다. 이때 스트림은 파일과의 연결을 끊는다.
// 
// fout.close();
// 
// close() 이후에는 fout을 이용하여 파일 쓰기를 할 수 없다. 다시 파일을 열어야 쓰기가 가능하다.
// 
// 
//
#include <iostream>
#include <fstream>
using namespace std;


int main() {
	char name[10], dept[20];
	int sid;


	cout << "이름>>";
	cin >> name;

	cout << "학번(숫자로)>>";
	cin >> sid;

	cout << "학과>>";
	cin >> dept;

	ofstream fout("c:\\temp\\student.txt");
	if (!fout) {
		cout << "c:\\temp\\student.txt 파일을 열 수 없다.";
		return 0;
	}

	fout << name << endl;	// name 쓰기
	fout << sid << endl;	// sid 쓰기
	fout << dept << endl;	// dept 쓰기


	fout.close();
}

// 잠깐! : 파일 열기와 닫기는 왜 필요한가?
// 
// 파일 열기(file open)란 경로명이 파일이 존재하는지, 파일 작성에 필요한 디스크 공간이 있는지, 읽기 전용
// 파일에 쓰기를 하는지, 접근 금지된 파일을 읽고자 하는지, 디스크는 정상적으로 작동하는지 등을 검사하는 과정이다.
// 이 모든 검사가 성공하였을 때 비로소 파일 열기가 성공하며 스트림과 연결된다. 파일 열기의 모든 과정은 운영체제에 의해
// 이루어진다.
// 
// 
// 반대로 파일 닫기(file close)란 파일 열기 시에 구성한 자료 구조를 해제하면 읽기/쓰기를 끝내는 과정이며, 버퍼에 남아 있는
// 데이터를 물리적으로 장치에 기록하는 마무리 작업도 포함이 된다. 파일 닫기를 하지 않고 프로그램이 비정상적으로 종료되는 경우,
// 버퍼에 남아 있는 데이터가 파일에 기록되지 않을 수도 있다. 가능하면 파일 닫기를 하는 것이 좋다.
// 
// 
// 
// 
// 
// 
//			>> 연산자를 이용한 텍스트 파일 읽기
// 
// 파일을 읽는 과정도 파일에 쓰는 과정과 유사하다. 우선 다음과 같이 ifstream 클래스를 이용하여 파일 입력 스트림 객체를
// 생성한다.
// 
// 
// ifstream fin; // 파일 입력 스트림 객체 fin 생성
// 
// 
// 그리고 open() 함수를 이용하여 파일을 읽고, 열기의 성공 여부를 검사한다.
// 
// fin.open("c:\\temp\\student.txt");
// if(!fin){
//		cout<<" 파일을 열 수 없다.";
//		return 0;
// }
// 
//